<html lang="en"><head>
  <meta charset="UTF-8">
  

    <link rel="apple-touch-icon" type="image/png" href="https://cpwebassets.codepen.io/assets/favicon/apple-touch-icon-5ae1a0698dcc2402e9712f7d01ed509a57814f994c660df9f7a952f3060705ee.png">

    <meta name="apple-mobile-web-app-title" content="CodePen">

    <link rel="shortcut icon" type="image/x-icon" href="https://cpwebassets.codepen.io/assets/favicon/favicon-aec34940fbc1a6e787974dcd360f2c6b63348d4b1f4e06c77743096d55480f33.ico">

    <link rel="mask-icon" type="image/x-icon" href="https://cpwebassets.codepen.io/assets/favicon/logo-pin-b4b4269c16397ad2f0f7a01bcdf513a1994f4c94b8af2f191c09eb0d601762b1.svg" color="#111">



  
  <title>CodePen - Word Search 2</title>
    <link rel="canonical" href="https://codepen.io/Conor092/pen/OZPMKd">
  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/5.0.0/normalize.min.css">

  
  
<style>
/**
* Wordfind.js 0.0.1
* (c) 2012 Bill, BunKat LLC.
* Wordfind is freely distributable under the MIT license.
* For all details and documentation:
*     https://github.com/bunkat/wordfind
*/
body {
  background: #306a8b;
}

.puzzleWrap {
  width: 850px;
  margin: 50px auto 0;
}

p {
  font: 22pt sans-serif;
  margin: 20px 20px 0px 45px;
  color: #6891ad;
}

/**
* Styles for the puzzle
*/
#puzzle {
  padding: 20px;
  float: left;
  margin: 30px 20px;
  width: 500px;
}

#puzzle div {
  width: 100%;
  margin: 0 auto;
}

/* style for each square in the puzzle */
#puzzle .puzzleSquare {
  height: 30px;
  width: 30px;
  text-transform: uppercase;
  background-color: #306a8b;
  border: 0;
  outline: none;
  font: 1em sans-serif;
  color: #6891ad;
}

button::-moz-focus-inner {
  border: none;
  outline: none;
}

/* indicates when a square has been selected */
#puzzle .selected {
  color: #ee5426;
  outline: none;
}
#puzzle .selected:focus {
  border: none;
}

/* indicates that the square is part of a word that has been found */
#puzzle .found {
  color: #c4c4c4;
}

#puzzle .solved {
  color: #ee5426;
}

/* indicates that all words have been found */
#puzzle .complete {
  background-color: green;
}

/**
* Styles for the word list
*/
#words {
  width: 250px;
  color: #6891ad;
  float: left;
  margin-top: 37px;
}

#words ul {
  list-style-type: none;
}

#words li {
  padding: 0 0 7px;
  font: 1em sans-serif;
  display: inline-block;
  float: left;
  width: 100px;
}

/* indicates that the word has been found */
#words .wordFound {
  text-decoration: line-through;
  color: #ee5426;
}

/**
* Styles for the button
*/
#solve {
  margin: 30px 30px 0 40px;
  background: transparent;
  color: #ee5426;
  padding: 10px 20px;
  border: 2px solid #ee5426;
  border-radius: 25px;
  opacity: 0.5;
  transition: opacity 0.25s ease-in;
}
#solve:hover, #solve.gameSolved {
  opacity: 1;
}
</style>

  <script>
  window.console = window.console || function(t) {};
</script>

  
  
</head>

<body translate="no">
  <div class="puzzleWrap">
  <p>Word Search</p>
  <div id="puzzle"><div><button class="puzzleSquare" x="0" y="0">j</button><button class="puzzleSquare" x="1" y="0">f</button><button class="puzzleSquare solved" x="2" y="0">c</button><button class="puzzleSquare solved" x="3" y="0">o</button><button class="puzzleSquare solved" x="4" y="0">l</button><button class="puzzleSquare solved" x="5" y="0">l</button><button class="puzzleSquare solved" x="6" y="0">a</button><button class="puzzleSquare solved" x="7" y="0">t</button><button class="puzzleSquare solved" x="8" y="0">e</button><button class="puzzleSquare solved" x="9" y="0">r</button><button class="puzzleSquare solved" x="10" y="0">a</button><button class="puzzleSquare solved" x="11" y="0">l</button><button class="puzzleSquare" x="12" y="0">e</button><button class="puzzleSquare" x="13" y="0">t</button><button class="puzzleSquare" x="14" y="0">t</button><button class="puzzleSquare" x="15" y="0">n</button><button class="puzzleSquare" x="16" y="0">n</button></div><div><button class="puzzleSquare found" x="0" y="1">s</button><button class="puzzleSquare found" x="1" y="1">h</button><button class="puzzleSquare found solved" x="2" y="1">a</button><button class="puzzleSquare found" x="3" y="1">r</button><button class="puzzleSquare found" x="4" y="1">i</button><button class="puzzleSquare found" x="5" y="1">n</button><button class="puzzleSquare found" x="6" y="1">g</button><button class="puzzleSquare" x="7" y="1">j</button><button class="puzzleSquare" x="8" y="1">h</button><button class="puzzleSquare solved" x="9" y="1">a</button><button class="puzzleSquare" x="10" y="1">d</button><button class="puzzleSquare" x="11" y="1">g</button><button class="puzzleSquare solved" x="12" y="1">t</button><button class="puzzleSquare" x="13" y="1">e</button><button class="puzzleSquare solved" x="14" y="1">s</button><button class="puzzleSquare" x="15" y="1">u</button><button class="puzzleSquare solved" x="16" y="1">m</button></div><div><button class="puzzleSquare" x="0" y="2">t</button><button class="puzzleSquare" x="1" y="2">h</button><button class="puzzleSquare solved" x="2" y="2">v</button><button class="puzzleSquare solved" x="3" y="2">s</button><button class="puzzleSquare" x="4" y="2">r</button><button class="puzzleSquare" x="5" y="2">j</button><button class="puzzleSquare solved" x="6" y="2">d</button><button class="puzzleSquare" x="7" y="2">o</button><button class="puzzleSquare" x="8" y="2">w</button><button class="puzzleSquare" x="9" y="2">j</button><button class="puzzleSquare solved" x="10" y="2">c</button><button class="puzzleSquare" x="11" y="2">b</button><button class="puzzleSquare solved" x="12" y="2">s</button><button class="puzzleSquare" x="13" y="2">s</button><button class="puzzleSquare solved" x="14" y="2">g</button><button class="puzzleSquare" x="15" y="2">i</button><button class="puzzleSquare solved" x="16" y="2">a</button></div><div><button class="puzzleSquare" x="0" y="3">b</button><button class="puzzleSquare" x="1" y="3">i</button><button class="puzzleSquare solved" x="2" y="3">a</button><button class="puzzleSquare solved" x="3" y="3">e</button><button class="puzzleSquare solved" x="4" y="3">s</button><button class="puzzleSquare solved" x="5" y="3">y</button><button class="puzzleSquare solved" x="6" y="3">e</button><button class="puzzleSquare" x="7" y="3">d</button><button class="puzzleSquare" x="8" y="3">k</button><button class="puzzleSquare" x="9" y="3">k</button><button class="puzzleSquare" x="10" y="3">k</button><button class="puzzleSquare solved" x="11" y="3">c</button><button class="puzzleSquare solved" x="12" y="3">e</button><button class="puzzleSquare" x="13" y="3">l</button><button class="puzzleSquare solved" x="14" y="3">n</button><button class="puzzleSquare" x="15" y="3">m</button><button class="puzzleSquare solved" x="16" y="3">r</button></div><div><button class="puzzleSquare" x="0" y="4">f</button><button class="puzzleSquare" x="1" y="4">v</button><button class="puzzleSquare solved" x="2" y="4">l</button><button class="puzzleSquare solved" x="3" y="4">c</button><button class="puzzleSquare" x="4" y="4">e</button><button class="puzzleSquare solved" x="5" y="4">e</button><button class="puzzleSquare solved" x="6" y="4">b</button><button class="puzzleSquare solved" x="7" y="4">u</button><button class="puzzleSquare solved" x="8" y="4">d</button><button class="puzzleSquare solved" x="9" y="4">g</button><button class="puzzleSquare solved" x="10" y="4">e</button><button class="puzzleSquare solved" x="11" y="4">t</button><button class="puzzleSquare solved" x="12" y="4">r</button><button class="puzzleSquare" x="13" y="4">f</button><button class="puzzleSquare solved" x="14" y="4">i</button><button class="puzzleSquare" x="15" y="4">e</button><button class="puzzleSquare solved" x="16" y="4">k</button></div><div><button class="puzzleSquare" x="0" y="5">s</button><button class="puzzleSquare solved" x="1" y="5">i</button><button class="puzzleSquare solved" x="2" y="5">u</button><button class="puzzleSquare solved" x="3" y="5">o</button><button class="puzzleSquare solved" x="4" y="5">c</button><button class="puzzleSquare solved" x="5" y="5">n</button><button class="puzzleSquare solved" x="6" y="5">t</button><button class="puzzleSquare solved" x="7" y="5">s</button><button class="puzzleSquare solved" x="8" y="5">e</button><button class="puzzleSquare solved" x="9" y="5">v</button><button class="puzzleSquare solved" x="10" y="5">n</button><button class="puzzleSquare solved" x="11" y="5">i</button><button class="puzzleSquare solved" x="12" y="5">e</button><button class="puzzleSquare solved" x="13" y="5">u</button><button class="puzzleSquare solved" x="14" y="5">v</button><button class="puzzleSquare" x="15" y="5">k</button><button class="puzzleSquare solved" x="16" y="5">e</button></div><div><button class="puzzleSquare" x="0" y="6">g</button><button class="puzzleSquare solved" x="1" y="6">n</button><button class="puzzleSquare solved" x="2" y="6">e</button><button class="puzzleSquare solved" x="3" y="6">n</button><button class="puzzleSquare solved" x="4" y="6">a</button><button class="puzzleSquare solved" x="5" y="6">o</button><button class="puzzleSquare solved" x="6" y="6">l</button><button class="puzzleSquare solved" x="7" y="6">s</button><button class="puzzleSquare solved" x="8" y="6">a</button><button class="puzzleSquare" x="9" y="6">u</button><button class="puzzleSquare solved" x="10" y="6">r</button><button class="puzzleSquare solved" x="11" y="6">d</button><button class="puzzleSquare solved" x="12" y="6">t</button><button class="puzzleSquare" x="13" y="6">r</button><button class="puzzleSquare solved" x="14" y="6">a</button><button class="puzzleSquare" x="15" y="6">p</button><button class="puzzleSquare solved" x="16" y="6">t</button></div><div><button class="puzzleSquare" x="0" y="7">y</button><button class="puzzleSquare solved" x="1" y="7">d</button><button class="puzzleSquare solved" x="2" y="7">n</button><button class="puzzleSquare solved" x="3" y="7">o</button><button class="puzzleSquare solved" x="4" y="7">b</button><button class="puzzleSquare solved" x="5" y="7">m</button><button class="puzzleSquare solved" x="6" y="7">u</button><button class="puzzleSquare" x="7" y="7">d</button><button class="puzzleSquare" x="8" y="7">d</button><button class="puzzleSquare solved" x="9" y="7">v</button><button class="puzzleSquare solved" x="10" y="7">a</button><button class="puzzleSquare solved" x="11" y="7">e</button><button class="puzzleSquare solved" x="12" y="7">n</button><button class="puzzleSquare" x="13" y="7">m</button><button class="puzzleSquare solved" x="14" y="7">s</button><button class="puzzleSquare solved" x="15" y="7">l</button><button class="puzzleSquare" x="16" y="7">g</button></div><div><button class="puzzleSquare" x="0" y="8">v</button><button class="puzzleSquare solved" x="1" y="8">e</button><button class="puzzleSquare" x="2" y="8">p</button><button class="puzzleSquare solved" x="3" y="8">m</button><button class="puzzleSquare" x="4" y="8">m</button><button class="puzzleSquare" x="5" y="8">b</button><button class="puzzleSquare solved" x="6" y="8">t</button><button class="puzzleSquare solved" x="7" y="8">n</button><button class="puzzleSquare solved" x="8" y="8">e</button><button class="puzzleSquare solved" x="9" y="8">m</button><button class="puzzleSquare solved" x="10" y="8">e</button><button class="puzzleSquare solved" x="11" y="8">r</button><button class="puzzleSquare solved" x="12" y="8">i</button><button class="puzzleSquare solved" x="13" y="8">t</button><button class="puzzleSquare solved" x="14" y="8">e</button><button class="puzzleSquare solved" x="15" y="8">r</button><button class="puzzleSquare" x="16" y="8">m</button></div><div><button class="puzzleSquare" x="0" y="9">f</button><button class="puzzleSquare solved" x="1" y="9">x</button><button class="puzzleSquare" x="2" y="9">d</button><button class="puzzleSquare solved" x="3" y="9">y</button><button class="puzzleSquare solved" x="4" y="9">c</button><button class="puzzleSquare solved" x="5" y="9">a</button><button class="puzzleSquare solved" x="6" y="9">p</button><button class="puzzleSquare solved" x="7" y="9">i</button><button class="puzzleSquare solved" x="8" y="9">t</button><button class="puzzleSquare solved" x="9" y="9">a</button><button class="puzzleSquare solved" x="10" y="9">l</button><button class="puzzleSquare solved" x="11" y="9">c</button><button class="puzzleSquare" x="12" y="9">u</button><button class="puzzleSquare" x="13" y="9">t</button><button class="puzzleSquare" x="14" y="9">d</button><button class="puzzleSquare" x="15" y="9">f</button><button class="puzzleSquare" x="16" y="9">g</button></div></div>
  <div id="words"><ul><li class="word account wordFound">account</li><li class="word accrual wordFound">accrual</li><li class="word assets wordFound">assets</li><li class="word bond wordFound">bond</li><li class="word budget wordFound">budget</li><li class="word capital wordFound">capital</li><li class="word collateral wordFound">collateral</li><li class="word credit wordFound">credit</li><li class="word debt wordFound">debt</li><li class="word earn wordFound">earn</li><li class="word economy wordFound">economy</li><li class="word index wordFound">index</li><li class="word interest wordFound">interest</li><li class="word invest wordFound">invest</li><li class="word loan wordFound">loan</li><li class="word market wordFound">market</li><li class="word money wordFound">money</li><li class="word retirement wordFound">retirement</li><li class="word save wordFound">save</li><li class="word savings wordFound">savings</li><li class="word sharing wordFound">sharing</li><li class="word value wordFound">value</li></ul>
    <button id="solve" class="gameSolved">Solve Puzzle</button>
  </div>
  
</div>
    <script src="https://cpwebassets.codepen.io/assets/common/stopExecutionOnTimeout-2c7831bb44f98c1391d6a4ffda0e1fd302503391ca806e7fcc7b9b87197aec26.js"></script>

  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.2.2/jquery.min.js"></script>
      <script id="rendered-js">
/**
* Wordfind.js 0.0.1
* (c) 2012 Bill, BunKat LLC.
* Wordfind is freely distributable under the MIT license.
* For all details and documentation:
*     https://github.com/bunkat/wordfind
*/

(function () {

  'use strict';

  /**
  * Generates a new word find (word search) puzzle provided a set of words.
  * Can automatically determine the smallest puzzle size in which all words
  * fit, or the puzzle size can be manually configured.  Will automatically
  * increase puzzle size until a valid puzzle is found.
  *
  * WordFind has no dependencies.
  */

  /**
  * Initializes the WordFind object.
  *
  * @api private
  */
  var WordFind = function () {

    // Letters used to fill blank spots in the puzzle
    var letters = 'abcdefghijklmnoprstuvwy';

    /**
    * Definitions for all the different orientations in which words can be
    * placed within a puzzle. New orientation definitions can be added and they
    * will be automatically available.
    */

    // The list of all the possible orientations
    var allOrientations = ['horizontal', 'horizontalBack', 'vertical', 'verticalUp',
    'diagonal', 'diagonalUp', 'diagonalBack', 'diagonalUpBack'];

    // The definition of the orientation, calculates the next square given a
    // starting square (x,y) and distance (i) from that square.
    var orientations = {
      horizontal: function (x, y, i) {return { x: x + i, y: y };},
      horizontalBack: function (x, y, i) {return { x: x - i, y: y };},
      vertical: function (x, y, i) {return { x: x, y: y + i };},
      verticalUp: function (x, y, i) {return { x: x, y: y - i };},
      diagonal: function (x, y, i) {return { x: x + i, y: y + i };},
      diagonalBack: function (x, y, i) {return { x: x - i, y: y + i };},
      diagonalUp: function (x, y, i) {return { x: x + i, y: y - i };},
      diagonalUpBack: function (x, y, i) {return { x: x - i, y: y - i };} };


    // Determines if an orientation is possible given the starting square (x,y),
    // the height (h) and width (w) of the puzzle, and the length of the word (l).
    // Returns true if the word will fit starting at the square provided using
    // the specified orientation.
    var checkOrientations = {
      horizontal: function (x, y, h, w, l) {return w >= x + l;},
      horizontalBack: function (x, y, h, w, l) {return x + 1 >= l;},
      vertical: function (x, y, h, w, l) {return h >= y + l;},
      verticalUp: function (x, y, h, w, l) {return y + 1 >= l;},
      diagonal: function (x, y, h, w, l) {return w >= x + l && h >= y + l;},
      diagonalBack: function (x, y, h, w, l) {return x + 1 >= l && h >= y + l;},
      diagonalUp: function (x, y, h, w, l) {return w >= x + l && y + 1 >= l;},
      diagonalUpBack: function (x, y, h, w, l) {return x + 1 >= l && y + 1 >= l;} };


    // Determines the next possible valid square given the square (x,y) was ]
    // invalid and a word lenght of (l).  This greatly reduces the number of
    // squares that must be checked. Returning {x: x+1, y: y} will always work
    // but will not be optimal.
    var skipOrientations = {
      horizontal: function (x, y, l) {return { x: 0, y: y + 1 };},
      horizontalBack: function (x, y, l) {return { x: l - 1, y: y };},
      vertical: function (x, y, l) {return { x: 0, y: y + 100 };},
      verticalUp: function (x, y, l) {return { x: 0, y: l - 1 };},
      diagonal: function (x, y, l) {return { x: 0, y: y + 1 };},
      diagonalBack: function (x, y, l) {return { x: l - 1, y: x >= l - 1 ? y + 1 : y };},
      diagonalUp: function (x, y, l) {return { x: 0, y: y < l - 1 ? l - 1 : y + 1 };},
      diagonalUpBack: function (x, y, l) {return { x: l - 1, y: x >= l - 1 ? y + 1 : y };} };


    /**
    * Initializes the puzzle and places words in the puzzle one at a time.
    *
    * Returns either a valid puzzle with all of the words or null if a valid
    * puzzle was not found.
    *
    * @param {[String]} words: The list of words to fit into the puzzle
    * @param {[Options]} options: The options to use when filling the puzzle
    */
    var fillPuzzle = function (words, options) {

      var puzzle = [],i,j,len;
      console.log('options = ', options);

      // initialize the puzzle with blanks
      for (i = 0; i < options.height; i++) {if (window.CP.shouldStopExecution(0)) break;
        puzzle.push([]);
        for (j = 0; j < options.width; j++) {if (window.CP.shouldStopExecution(1)) break;
          puzzle[i].push('');
        }window.CP.exitedLoop(1);
      }

      // add each word into the puzzle one at a time
      window.CP.exitedLoop(0);for (i = 0, len = words.length; i < len; i++) {if (window.CP.shouldStopExecution(2)) break;
        if (!placeWordInPuzzle(puzzle, options, words[i])) {
          // if a word didn't fit in the puzzle, give up
          return null;
        }
      }

      // return the puzzle
      window.CP.exitedLoop(2);return puzzle;
    };

    /**
    * Adds the specified word to the puzzle by finding all of the possible
    * locations where the word will fit and then randomly selecting one. Options
    * controls whether or not word overlap should be maximized.
    *
    * Returns true if the word was successfully placed, false otherwise.
    *
    * @param {[[String]]} puzzle: The current state of the puzzle
    * @param {[Options]} options: The options to use when filling the puzzle
    * @param {String} word: The word to fit into the puzzle.
    */
    var placeWordInPuzzle = function (puzzle, options, word) {

      // find all of the best locations where this word would fit
      var locations = findBestLocations(puzzle, options, word);

      if (locations.length === 0) {
        return false;
      }

      // select a location at random and place the word there
      var sel = locations[Math.floor(Math.random() * locations.length)];
      placeWord(puzzle, word, sel.x, sel.y, orientations[sel.orientation]);

      return true;
    };

    /**
    * Iterates through the puzzle and determines all of the locations where
    * the word will fit. Options determines if overlap should be maximized or
    * not.
    *
    * Returns a list of location objects which contain an x,y cooridinate
    * indicating the start of the word, the orientation of the word, and the
    * number of letters that overlapped with existing letter.
    *
    * @param {[[String]]} puzzle: The current state of the puzzle
    * @param {[Options]} options: The options to use when filling the puzzle
    * @param {String} word: The word to fit into the puzzle.
    */
    var findBestLocations = function (puzzle, options, word) {

      var locations = [],
      height = options.height,
      width = options.width,
      wordLength = word.length,
      maxOverlap = 0; // we'll start looking at overlap = 0

      // loop through all of the possible orientations at this position
      for (var k = 0, len = options.orientations.length; k < len; k++) {if (window.CP.shouldStopExecution(3)) break;

        var orientation = options.orientations[k],
        check = checkOrientations[orientation],
        next = orientations[orientation],
        skipTo = skipOrientations[orientation],
        x = 0,y = 0;

        // loop through every position on the board
        while (y < height) {if (window.CP.shouldStopExecution(4)) break;

          // see if this orientation is even possible at this location
          if (check(x, y, height, width, wordLength)) {

            // determine if the word fits at the current position
            var overlap = calcOverlap(word, puzzle, x, y, next);

            // if the overlap was bigger than previous overlaps that we've seen
            if (overlap >= maxOverlap || !options.preferOverlap && overlap > -1) {
              maxOverlap = overlap;
              locations.push({ x: x, y: y, orientation: orientation, overlap: overlap });
            }

            x++;
            if (x >= width) {
              x = 0;
              y++;
            }
          } else
          {
            // if current cell is invalid, then skip to the next cell where
            // this orientation is possible. this greatly reduces the number
            // of checks that we have to do overall
            var nextPossible = skipTo(x, y, wordLength);
            x = nextPossible.x;
            y = nextPossible.y;
          }

        }window.CP.exitedLoop(4);
      }

      // finally prune down all of the possible locations we found by
      // only using the ones with the maximum overlap that we calculated
      window.CP.exitedLoop(3);return options.preferOverlap ?
      pruneLocations(locations, maxOverlap) :
      locations;
    };

    /**
    * Determines whether or not a particular word fits in a particular
    * orientation within the puzzle.
    *
    * Returns the number of letters overlapped with existing words if the word
    * fits in the specified position, -1 if the word does not fit.
    *
    * @param {String} word: The word to fit into the puzzle.
    * @param {[[String]]} puzzle: The current state of the puzzle
    * @param {int} x: The x position to check
    * @param {int} y: The y position to check
    * @param {function} fnGetSquare: Function that returns the next square
    */
    var calcOverlap = function (word, puzzle, x, y, fnGetSquare) {
      var overlap = 0;

      // traverse the squares to determine if the word fits
      for (var i = 0, len = word.length; i < len; i++) {if (window.CP.shouldStopExecution(5)) break;

        var next = fnGetSquare(x, y, i),
        square = puzzle[next.y][next.x];

        // if the puzzle square already contains the letter we
        // are looking for, then count it as an overlap square
        if (square === word[i]) {
          overlap++;
        }
        // if it contains a different letter, than our word doesn't fit
        // here, return -1
        else if (square !== '') {
            return -1;
          }
      }

      // if the entire word is overlapping, skip it to ensure words aren't
      // hidden in other words
      window.CP.exitedLoop(5);return overlap;
    };

    /**
    * If overlap maximization was indicated, this function is used to prune the
    * list of valid locations down to the ones that contain the maximum overlap
    * that was previously calculated.
    *
    * Returns the pruned set of locations.
    *
    * @param {[Location]} locations: The set of locations to prune
    * @param {int} overlap: The required level of overlap
    */
    var pruneLocations = function (locations, overlap) {

      var pruned = [];
      for (var i = 0, len = locations.length; i < len; i++) {if (window.CP.shouldStopExecution(6)) break;
        if (locations[i].overlap >= overlap) {
          pruned.push(locations[i]);
        }
      }window.CP.exitedLoop(6);

      return pruned;
    };

    /**
    * Places a word in the puzzle given a starting position and orientation.
    *
    * @param {[[String]]} puzzle: The current state of the puzzle
    * @param {String} word: The word to fit into the puzzle.
    * @param {int} x: The x position to check
    * @param {int} y: The y position to check
    * @param {function} fnGetSquare: Function that returns the next square
    */
    var placeWord = function (puzzle, word, x, y, fnGetSquare) {
      for (var i = 0, len = word.length; i < len; i++) {if (window.CP.shouldStopExecution(7)) break;
        var next = fnGetSquare(x, y, i);
        puzzle[next.y][next.x] = word[i];
      }window.CP.exitedLoop(7);
    };

    return {

      /**
      * Returns the list of all of the possible orientations.
      * @api public
      */
      validOrientations: allOrientations,

      /**
      * Returns the orientation functions for traversing words.
      * @api public
      */
      orientations: orientations,

      /**
      * Generates a new word find (word search) puzzle.
      *
      * Settings:
      *
      * height: desired height of the puzzle, default: smallest possible
      * width:  desired width of the puzzle, default: smallest possible
      * orientations: list of orientations to use, default: all orientations
      * fillBlanks: true to fill in the blanks, default: true
      * maxAttempts: number of tries before increasing puzzle size, default:3
      * preferOverlap: maximize word overlap or not, default: true
      *
      * Returns the puzzle that was created.
      *
      * @param {[String]} words: List of words to include in the puzzle
      * @param {options} settings: The options to use for this puzzle
      * @api public
      */
      newPuzzle: function (words, settings) {
        var wordList,puzzle,attempts = 0,opts = settings || {};

        console.log('newPuzzle() :: settings = ', settings);

        // copy and sort the words by length, inserting words into the puzzle
        // from longest to shortest works out the best
        wordList = words.slice(0).sort(function (a, b) {
          return a.length < b.length ? 1 : 0;
        });

        // initialize the options
        var options = {
          height: opts.height || wordList[0].length,
          width: opts.width || wordList[0].length,
          orientations: opts.orientations || allOrientations,
          fillBlanks: opts.fillBlanks !== undefined ? opts.fillBlanks : true,
          maxAttempts: opts.maxAttempts || 3,
          preferOverlap: opts.preferOverlap !== undefined ? opts.preferOverlap : true };


        // add the words to the puzzle
        // since puzzles are random, attempt to create a valid one up to
        // maxAttempts and then increase the puzzle size and try again
        while (!puzzle) {if (window.CP.shouldStopExecution(8)) break;
          while (!puzzle && attempts++ < options.maxAttempts) {if (window.CP.shouldStopExecution(9)) break;
            puzzle = fillPuzzle(wordList, options);
          }window.CP.exitedLoop(9);

          if (!puzzle) {
            options.height++;
            options.width++;
            attempts = 0;
          }
        }

        // fill in empty spaces with random letters
        window.CP.exitedLoop(8);if (options.fillBlanks) {
          this.fillBlanks(puzzle, options);
        }

        return puzzle;
      },

      /**
      * Fills in any empty spaces in the puzzle with random letters.
      *
      * @param {[[String]]} puzzle: The current state of the puzzle
      * @api public
      */
      fillBlanks: function (puzzle) {
        for (var i = 0, height = puzzle.length; i < height; i++) {if (window.CP.shouldStopExecution(10)) break;
          var row = puzzle[i];
          for (var j = 0, width = row.length; j < width; j++) {if (window.CP.shouldStopExecution(11)) break;

            if (!puzzle[i][j]) {
              var randomLetter = Math.floor(Math.random() * letters.length);
              puzzle[i][j] = letters[randomLetter];
            }
          }window.CP.exitedLoop(11);
        }window.CP.exitedLoop(10);
      },

      /**
      * Returns the starting location and orientation of the specified words
      * within the puzzle. Any words that are not found are returned in the
      * notFound array.
      *
      * Returns
      *   x position of start of word
      *   y position of start of word
      *   orientation of word
      *   word
      *   overlap (always equal to word.length)
      *
      * @param {[[String]]} puzzle: The current state of the puzzle
      * @param {[String]} words: The list of words to find
      * @api public
      */
      solve: function (puzzle, words) {
        var options = {
          height: puzzle.length,
          width: puzzle[0].length,
          orientations: allOrientations,
          preferOverlap: true },

        found = [],
        notFound = [];

        for (var i = 0, len = words.length; i < len; i++) {if (window.CP.shouldStopExecution(12)) break;
          var word = words[i],
          locations = findBestLocations(puzzle, options, word);

          if (locations.length > 0 && locations[0].overlap === word.length) {
            locations[0].word = word;
            found.push(locations[0]);
          } else
          {
            notFound.push(word);
          }
        }window.CP.exitedLoop(12);

        return { found: found, notFound: notFound };
      },

      /**
      * Outputs a puzzle to the console, useful for debugging.
      * Returns a formatted string representing the puzzle.
      *
      * @param {[[String]]} puzzle: The current state of the puzzle
      * @api public
      */
      print: function (puzzle) {
        var puzzleString = '';
        for (var i = 0, height = puzzle.length; i < height; i++) {if (window.CP.shouldStopExecution(13)) break;
          var row = puzzle[i];
          for (var j = 0, width = row.length; j < width; j++) {if (window.CP.shouldStopExecution(14)) break;
            puzzleString += (row[j] === '' ? ' ' : row[j]) + ' ';
          }window.CP.exitedLoop(14);
          puzzleString += '\n';
        }window.CP.exitedLoop(13);

        console.log(puzzleString);
        return puzzleString;
      } };

  };

  /**
  * Allow library to be used within both the browser and node.js
  */
  var root = typeof exports !== "undefined" && exports !== null ? exports : window;
  root.wordfind = WordFind();

}).call(this);

/**
===========================================================================
===========================================================================
===========================================================================
===========================================================================
===========================================================================
===========================================================================
===========================================================================
===========================================================================
===========================================================================
===========================================================================
===========================================================================
===========================================================================
===========================================================================
===========================================================================
===========================================================================
===========================================================================
===========================================================================
===========================================================================
*/

/**
* Wordfind.js 0.0.1
* (c) 2012 Bill, BunKat LLC.
* Wordfind is freely distributable under the MIT license.
* For all details and documentation:
*     https://github.com/bunkat/wordfind
*/

(function (document, $, wordfind) {

  'use strict';

  /**
  * An example game using the puzzles created from wordfind.js. Click and drag
  * to highlight words.
  *
  * WordFindGame requires wordfind.js and jQuery.
  */

  /**
  * Initializes the WordFindGame object.
  *
  * @api private
  */
  var WordFindGame = function () {

    // List of words for this game
    var wordList;

    /**
    * Draws the puzzle by inserting rows of buttons into el.
    *
    * @param {String} el: The jQuery element to write the puzzle to
    * @param {[[String]]} puzzle: The puzzle to draw
    */
    var drawPuzzle = function (el, puzzle) {
      console.log('drawPuzzle()');
      var output = '';
      // for each row in the puzzle
      for (var i = 0, height = puzzle.length; i < height; i++) {if (window.CP.shouldStopExecution(15)) break;
        // append a div to represent a row in the puzzle
        var row = puzzle[i];
        output += '<div>';
        // for each element in that row
        for (var j = 0, width = row.length; j < width; j++) {if (window.CP.shouldStopExecution(16)) break;
          // append our button with the appropriate class
          output += '<button class="puzzleSquare" x="' + j + '" y="' + i + '">';
          output += row[j] || '&nbsp;';
          output += '</button>';
        }
        // close our div that represents a row
        window.CP.exitedLoop(16);output += '</div>';
      }window.CP.exitedLoop(15);

      $(el).html(output);
    };

    /**
    * Draws the words by inserting an unordered list into el.
    *
    * @param {String} el: The jQuery element to write the words to
    * @param {[String]} words: The words to draw
    */
    var drawWords = function (el, words) {

      var output = '<ul>';
      for (var i = 0, len = words.length; i < len; i++) {if (window.CP.shouldStopExecution(17)) break;
        var word = words[i];
        output += '<li class="word ' + word + '">' + word;
      }window.CP.exitedLoop(17);
      output += '</ul>';

      $(el).prepend(output);
    };


    /**
    * Game play events.
    *
    * The following events handle the turns, word selection, word finding, and
    * game end.
    *
    */

    // Game state
    var startSquare,selectedSquares = [],curOrientation,curWord = '';

    /**
    * Event that handles mouse down on a new square. Initializes the game state
    * to the letter that was selected.
    *
    */
    var startTurn = function () {
      $(this).addClass('selected');
      startSquare = this;
      selectedSquares.push(this);
      curWord = $(this).text();
    };



    /**
    * Event that handles mouse over on a new square. Ensures that the new square
    * is adjacent to the previous square and the new square is along the path
    * of an actual word.
    *
    */
    var select = function (target) {
      // if the user hasn't started a word yet, just return
      if (!startSquare) {
        return;
      }

      // if the new square is actually the previous square, just return
      var lastSquare = selectedSquares[selectedSquares.length - 1];
      if (lastSquare == target) {
        return;
      }

      // see if the user backed up and correct the selectedSquares state if
      // they did
      var backTo;
      for (var i = 0, len = selectedSquares.length; i < len; i++) {if (window.CP.shouldStopExecution(18)) break;
        if (selectedSquares[i] == target) {
          backTo = i + 1;
          break;
        }
      }window.CP.exitedLoop(18);

      while (backTo < selectedSquares.length) {if (window.CP.shouldStopExecution(19)) break;
        $(selectedSquares[selectedSquares.length - 1]).removeClass('selected');
        selectedSquares.splice(backTo, 1);
        curWord = curWord.substr(0, curWord.length - 1);
      }


      // see if this is just a new orientation from the first square
      // this is needed to make selecting diagonal words easier
      window.CP.exitedLoop(19);var newOrientation = calcOrientation(
      $(startSquare).attr('x') - 0,
      $(startSquare).attr('y') - 0,
      $(target).attr('x') - 0,
      $(target).attr('y') - 0);


      if (newOrientation) {
        selectedSquares = [startSquare];
        curWord = $(startSquare).text();
        if (lastSquare !== startSquare) {
          $(lastSquare).removeClass('selected');
          lastSquare = startSquare;
        }
        curOrientation = newOrientation;
      }

      // see if the move is along the same orientation as the last move
      var orientation = calcOrientation(
      $(lastSquare).attr('x') - 0,
      $(lastSquare).attr('y') - 0,
      $(target).attr('x') - 0,
      $(target).attr('y') - 0);


      // if the new square isn't along a valid orientation, just ignore it.
      // this makes selecting diagonal words less frustrating
      if (!orientation) {
        return;
      }

      // finally, if there was no previous orientation or this move is along
      // the same orientation as the last move then play the move
      if (!curOrientation || curOrientation === orientation) {
        curOrientation = orientation;
        playTurn(target);
      }

    };

    var touchMove = function (e) {
      var xPos = e.originalEvent.touches[0].pageX;
      var yPos = e.originalEvent.touches[0].pageY;
      var targetElement = document.elementFromPoint(xPos, yPos);
      select(targetElement);
    };

    var mouseMove = function () {
      select(this);
    };

    /**
    * Updates the game state when the previous selection was valid.
    *
    * @param {el} square: The jQuery element that was played
    */
    var playTurn = function (square) {

      // make sure we are still forming a valid word
      for (var i = 0, len = wordList.length; i < len; i++) {if (window.CP.shouldStopExecution(20)) break;
        if (wordList[i].indexOf(curWord + $(square).text()) === 0) {
          $(square).addClass('selected');
          selectedSquares.push(square);
          curWord += $(square).text();
          break;
        }
      }window.CP.exitedLoop(20);
    };

    /**
    * Event that handles mouse up on a square. Checks to see if a valid word
    * was created and updates the class of the letters and word if it was. Then
    * resets the game state to start a new word.
    *
    */
    var endTurn = function () {

      // see if we formed a valid word
      for (var i = 0, len = wordList.length; i < len; i++) {if (window.CP.shouldStopExecution(21)) break;

        if (wordList[i] === curWord) {
          $('.selected').addClass('found');
          wordList.splice(i, 1);
          $('.' + curWord).addClass('wordFound');
        }

        if (wordList.length === 0) {
          $('.puzzleSquare').addClass('complete');
        }
      }

      // reset the turn
      window.CP.exitedLoop(21);$('.selected').removeClass('selected');
      startSquare = null;
      selectedSquares = [];
      curWord = '';
      curOrientation = null;
    };

    /**
    * Given two points, ensure that they are adjacent and determine what
    * orientation the second point is relative to the first
    *
    * @param {int} x1: The x coordinate of the first point
    * @param {int} y1: The y coordinate of the first point
    * @param {int} x2: The x coordinate of the second point
    * @param {int} y2: The y coordinate of the second point
    */
    var calcOrientation = function (x1, y1, x2, y2) {

      for (var orientation in wordfind.orientations) {
        var nextFn = wordfind.orientations[orientation];
        var nextPos = nextFn(x1, y1, 1);

        if (nextPos.x === x2 && nextPos.y === y2) {
          return orientation;
        }
      }

      return null;
    };

    return {

      /**
      * Creates a new word find game and draws the board and words.
      *
      * Returns the puzzle that was created.
      *
      * @param {[String]} words: The words to add to the puzzle
      * @param {String} puzzleEl: Selector to use when inserting the puzzle
      * @param {String} wordsEl: Selector to use when inserting the word list
      * @param {Options} options: WordFind options to use when creating the puzzle
      */
      create: function (words, puzzleEl, wordsEl, options) {

        wordList = words.slice(0).sort();

        var puzzle = wordfind.newPuzzle(words, options);

        console.log('puzzle = ', puzzle);

        // draw out all of the words
        drawPuzzle(puzzleEl, puzzle);
        drawWords(wordsEl, wordList);

        // attach events to the buttons
        // optimistically add events for windows 8 touch
        if (window.navigator.msPointerEnabled) {
          $('.puzzleSquare').on('MSPointerDown', startTurn);
          $('.puzzleSquare').on('MSPointerOver', select);
          $('.puzzleSquare').on('MSPointerUp', endTurn);
        } else
        {
          $('.puzzleSquare').mousedown(startTurn);
          $('.puzzleSquare').mouseenter(mouseMove);
          $('.puzzleSquare').mouseup(endTurn);
          $('.puzzleSquare').on("touchstart", startTurn);
          $('.puzzleSquare').on("touchmove", touchMove);
          $('.puzzleSquare').on("touchend", endTurn);
        }

        return puzzle;
      },

      /**
      * Solves an existing puzzle.
      *
      * @param {[[String]]} puzzle: The puzzle to solve
      * @param {[String]} words: The words to solve for
      */
      solve: function (puzzle, words) {

        var solution = wordfind.solve(puzzle, words).found;

        for (var i = 0, len = solution.length; i < len; i++) {if (window.CP.shouldStopExecution(22)) break;
          var word = solution[i].word,
          orientation = solution[i].orientation,
          x = solution[i].x,
          y = solution[i].y,
          next = wordfind.orientations[orientation];

          if (!$('.' + word).hasClass('wordFound')) {
            for (var j = 0, size = word.length; j < size; j++) {if (window.CP.shouldStopExecution(23)) break;
              var nextPos = next(x, y, j);
              $('[x="' + nextPos.x + '"][y="' + nextPos.y + '"]').addClass('solved');
            }window.CP.exitedLoop(23);

            $('.' + word).addClass('wordFound');
          }
        }window.CP.exitedLoop(22);

        $('#solve').addClass('gameSolved');

      } };

  };


  /**
  * Allow game to be used within the browser
  */
  window.wordfindgame = WordFindGame();

})(document, jQuery, wordfind);

$(function () {
  var words = ['save', 'earn', 'invest', 'retirement', 'account', 'money', 'credit', 'debt', 'assets', 'loan', 'interest', 'accrual',
  'economy', 'sharing', 'savings', 'budget', 'capital', 'collateral', 'bond', 'market', 'value', 'index'];
  // start a word find game
  var gamePuzzle = wordfindgame.create(
  words,
  '#puzzle',
  '#words',
  { height: 8,
    width: 15,
    fillBlanks: true });

  $('#solve').click(function () {
    wordfindgame.solve(gamePuzzle, words);
  });
  // create just a puzzle, without filling in the blanks and print to console
  var puzzle = wordfind.newPuzzle(
  words,
  { height: 5, width: 15, fillBlanks: true });

  wordfind.print(puzzle);
});
//# sourceURL=pen.js
    </script>

  



</body></html>